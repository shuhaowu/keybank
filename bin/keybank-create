#!/usr/bin/env python
from __future__ import print_function

import argparse
import os
import sys

DEFAULT_KEYBANK_SIZE = 128 * 1024 * 1024  # 128 MB

KEY_DIRECTORY_README = """
This contains all the keys.

Please structure this directory as if it is your rootfs. Example, a key in
/etc/nginx/ssl/example.key will go into etc/nginx/ssl/example.key under this
directory.
""".strip()


def fatal(msg):
  print("ERROR: {}".format(msg), file=sys.stderr)
  sys.exit(1)


def execute(command):
  print("EXECUTING: {}".format(command))
  status = os.system(command)
  if status != 0:
    fatal("{} failed with status {}".format(command, status))


def try_parsing_arguments():
  parser = argparse.ArgumentParser(description="creates an empty keybank file that is LUKSed encrypted. this tool must run as root.")
  parser.add_argument(
    "-s", "--size",
    type=int,
    default=DEFAULT_KEYBANK_SIZE,
    help="the size of the keybank in bytes. default: {} ({}MB)".format(DEFAULT_KEYBANK_SIZE, DEFAULT_KEYBANK_SIZE / 1024 / 1024)
  )

  parser.add_argument(
    "path",
    help="the path to the keybank file to be created. ensure the parent of this path is owned by root"
  )

  args = parser.parse_args()
  if os.path.exists(args.path):
    fatal("{} already exists".format(args.path))

  parent_dir = os.path.dirname(os.path.abspath(args.path))
  if not os.path.isdir(parent_dir):
    fatal("{} is not a directory".format(parent_dir))

  parent_stat = os.stat(parent_dir)
  if parent_stat.st_uid != 0 or parent_stat.st_gid != 0:
    fatal("{} must be owned by root".format(parent_dir))

  args.mount_path = os.path.join("/mnt", "keybank-" + os.path.basename(args.path))
  if not os.path.exists(args.mount_path):
    os.mkdir(args.mount_path)

  return args


def main():
  if os.geteuid() != 0:
    fatal("must be root to run this.")

  os.umask(077)

  args = try_parsing_arguments()
  create_sparse_file(args.path, args.size)
  do_crypt_setup(args.path, args.mount_path)

  os.chdir(args.mount_path)
  os.mkdir("keys")
  os.chdir(os.path.join(args.mount_path, "keys"))
  execute("git init")

  with open("README", "w") as f:
    f.write(KEY_DIRECTORY_README)

  with open("manifest.json", "w") as f:
    f.write("[]")

  execute("git add .")
  execute("git commit -am 'Initial commit'")

  print("")
  print("==========================")
  print("KEYBANK BOOTSTRAP COMPLETE")
  print("==========================")
  print("")
  print("Done creating keybank. It should be mounted at {}".format(args.mount_path))
  print("To go into it, you need to be root.")
  print("")
  print("To unmount, do:")
  print("# keybank-detach {}".format(os.path.basename(args.path)))


def create_sparse_file(path, size):
  with open(path, "w") as f:
    f.seek(size-1)
    f.write('\0')

  os.chmod(path, 0600)


def do_crypt_setup(path, mount_path):
  mapping_name = os.path.basename(path)
  execute("cryptsetup -y luksFormat {}".format(path))
  execute("cryptsetup luksOpen {} {}".format(path, mapping_name))

  mapper_path = "/dev/mapper/{}".format(mapping_name)
  if not os.path.exists(mapper_path):
    fatal("luksOpen executed by {} does not exist".format(mapper_path))
  execute("mkfs.ext4 {}".format(mapper_path))
  execute("mount {} {}".format(mapper_path, mount_path))
  # TODO: shouldn't umask from main work here? Apparently it doesn't on my system?
  # Needs investigation... Shouldn't have to do this.
  execute("chmod 0700 {}".format(mount_path))
  return mapper_path


if __name__ == "__main__":
  main()
